<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>橙柚养乐多的博客</title>
  
  <subtitle>记录与领悟</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="https://ferrerobomb.github.io/"/>
  <updated>2022-02-27T07:45:27.701Z</updated>
  <id>https://ferrerobomb.github.io/</id>
  
  <author>
    <name>橙柚养乐多</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode中国版目录</title>
    <link href="https://ferrerobomb.github.io/2099/02/19/leetcode%E4%B8%AD%E5%9B%BD%E7%89%88%E7%9B%AE%E5%BD%95/"/>
    <id>https://ferrerobomb.github.io/2099/02/19/leetcode中国版目录/</id>
    <published>2099-02-19T15:44:03.000Z</published>
    <updated>2022-02-27T07:45:27.701Z</updated>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><table><thead><tr><th>序号.题目.leetcode地址</th><th>题目.解法.地址</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></td><td><a href="https://ferrerobomb.github.io/2022/01/20/leetcode-1.两数之和/">leetcode-1.两数之和</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></td><td><a href="https://ferrerobomb.github.io/2022/01/25/leetcode-2.两数相加/">leetcode-2.两数相加</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></td><td><a href="https://ferrerobomb.github.io/2022/01/28/leetcode-3.无重复字符的最长子串/">leetcode-3.无重复字符的最长子串</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-6.Z字形变换/">leetcode-6.Z字形变换</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. 整数反转</a></td><td><a href="https://ferrerobomb.github.io/2022/01/07/leetcode-7. 整数反转/">leetcode-7. 整数反转</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. 回文数</a></td><td><a href="https://ferrerobomb.github.io/2022/02/04/leetcode-9.回文数/">leetcode-9.回文数</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></td><td><a href="https://ferrerobomb.github.io/2022/02/24/leetcode-17. 电话号码的字母组合/">leetcode-17. 电话号码的字母组合</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-20-有效的括号/">leetcode-20.有效的括号</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></td><td><a href="https://ferrerobomb.github.io/2022/02/19/leetcode-21.合并两个有序链表/">leetcode-21.合并两个有序链表</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></td><td><a href="https://ferrerobomb.github.io/2022/01/22/leetcode-22.括号生成/">leetcode-22.括号生成</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a></td><td><a href="https://ferrerobomb.github.io/2022/01/06/leetcode-28. 实现 strStr(">leetcode-28. 实现 strStr()</a>/)</td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></td><td><a href="https://ferrerobomb.github.io/2022/01/14/leetcode-33.搜索旋转排序数组/">leetcode-33.搜索旋转排序数组</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></td><td><a href="https://ferrerobomb.github.io/2022/02/27/leetcode-35. 搜索插入位置/">leetcode-35. 搜索插入位置</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘</a></td><td><a href="https://ferrerobomb.github.io/2022/02/23/leetcode-43. 字符串相乘/">leetcode-43. 字符串相乘</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子数组和</a></td><td><a href="https://ferrerobomb.github.io/2022/01/29/leetcode-53.最大子数组和/">leetcode-53. 最大子数组和</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-54-螺旋矩阵/">leetcode-54.螺旋矩阵</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></td><td><a href="https://ferrerobomb.github.io/2022/01/10/leetcode-56. 合并区间/">leetcode-56. 合并区间</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></td><td><a href="https://ferrerobomb.github.io/2022/01/21/leetcode-62.不同路径/">leetcode-62.不同路径</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></td><td><a href="https://ferrerobomb.github.io/2022/01/24/leetcode-70.爬楼梯/">leetcode-70.爬楼梯</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></td><td><a href="https://ferrerobomb.github.io/2022/01/30/leetcode-75.颜色分类/">leetcode-75.颜色分类</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></td><td><a href="https://ferrerobomb.github.io/2022/02/08/leetcode-78.子集/">leetcode-78.子集</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></td><td><a href="https://ferrerobomb.github.io/2022/01/23/leetcode-79.单词搜索/">leetcode-79.单词搜索</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></td><td><a href="https://ferrerobomb.github.io/2022/02/01/leetcode-88.合并两个有序数组/">leetcode-88.合并两个有序数组</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></td><td><a href="https://ferrerobomb.github.io/2020/02/26/leetcode-94-144-145-二叉树的遍历/">leetcode-94/144/145-二叉树的遍历</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></td><td><a href="https://ferrerobomb.github.io/2022/02/26/leetcode-98. 验证二叉搜索树/">leetcode-98. 验证二叉搜索树</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></td><td><a href="https://ferrerobomb.github.io/2022/02/22/leetcode-100. 相同的树/">leetcode-100. 相同的树</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></td><td><a href="https://ferrerobomb.github.io/2022/02/11/leetcode-102.二叉树的层序遍历/">leetcode-102.二叉树的层序遍历</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-118.杨辉三角/">leetcode-118.杨辉三角</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></td><td><a href="https://ferrerobomb.github.io/2022/02/20/leetcode-136.只出现一次的数字/">leetcode-136.只出现一次的数字</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137. 只出现一次的数字 II</a></td><td><a href="https://ferrerobomb.github.io/2022/01/08/leetcode-137. 只出现一次的数字 II/">leetcode-137. 只出现一次的数字 II</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></td><td><a href="https://ferrerobomb.github.io/2020/02/26/leetcode-94-144-145-二叉树的遍历/">leetcode-94/144/145-二叉树的遍历</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></td><td><a href="https://ferrerobomb.github.io/2020/02/26/leetcode-94-144-145-二叉树的遍历/">leetcode-94/144/145-二叉树的遍历</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/compare-version-numbers/" target="_blank" rel="noopener">165. 比较版本号</a></td><td><a href="https://ferrerobomb.github.io/2022/02/07/leetcode-165.比较版本号/">leetcode-165.比较版本号</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">168. Excel表列名称</a></td><td><a href="https://ferrerobomb.github.io/2022/01/31/leetcode-168.Excel表列名称/">leetcode-168.Excel表列名称</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">171. Excel 表列序号</a></td><td><a href="https://ferrerobomb.github.io/2022/02/03/leetcode-171.Excel 表列序号/">leetcode-171.Excel 表列序号</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/duplicate-emails/" target="_blank" rel="noopener">182. 查找重复的电子邮箱</a></td><td><a href="https://ferrerobomb.github.io/2022/02/02/leetcode-182.查找重复的电子邮箱/">leetcode-182.查找重复的电子邮箱</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/word-frequency/" target="_blank" rel="noopener">192. 统计词频</a></td><td><a href="https://ferrerobomb.github.io/2022/02/06/leetcode-192.统计词频/">leetcode-192.统计词频</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-198-打家劫舍/">leetcode-198.打家劫舍</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></td><td><a href="https://ferrerobomb.github.io/2022/02/18/leetcode-206.反转链表/">leetcode-206.反转链表</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></td><td><a href="https://ferrerobomb.github.io/2022/02/14/leetcode-222.完全二叉树的节点个数/">leetcode-222.完全二叉树的节点个数</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">283. 移动零</a></td><td><a href="https://ferrerobomb.github.io/2022/02/09/leetcode-283.移动零/">leetcode-283.移动零</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-322-零钱兑换/">leetcode-322.零钱兑换</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/arithmetic-slices" target="_blank" rel="noopener">413. 等差数列划分</a></td><td><a href="https://ferrerobomb.github.io/2021/08/19/leetcode-413-等差数列划分/">leetcode-413.等差数列划分</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N 叉树的层序遍历</a></td><td><a href="https://ferrerobomb.github.io/2022/02/17/leetcode-429.N叉树的层序遍历/">leetcode-429.N叉树的层序遍历</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a></td><td><a href="https://ferrerobomb.github.io/2022/02/10/leetcode-445.两数相加 II/">leetcode-445.两数相加 II</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence" target="_blank" rel="noopener">516. 最长回文子序列</a></td><td><a href="https://ferrerobomb.github.io/2021/08/19/leetcode-516-最长回文子序列/">leetcode-516.最长回文子序列</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener">559. N 叉树的最大深度</a></td><td><a href="https://ferrerobomb.github.io/2022/02/16/leetcode-559.N叉树的最大深度/">leetcode-559.N叉树的最大深度</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N 叉树的前序遍历</a></td><td><a href="https://ferrerobomb.github.io/2022/02/13/leetcode-589.N叉树的前序遍历/">leetcode-589.N叉树的前序遍历</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N 叉树的后序遍历</a></td><td><a href="https://ferrerobomb.github.io/2022/02/15/leetcode-590.N叉树的后序遍历/">leetcode-590.N叉树的后序遍历</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/push-dominoes/" target="_blank" rel="noopener">838. 推多米诺</a></td><td><a href="https://ferrerobomb.github.io/2022/02/21/leetcode-838. 推多米诺/">leetcode-838. 推多米诺</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a></td><td><a href="https://ferrerobomb.github.io/2022/01/13/leetcode-912.排序数组/">leetcode-912.排序数组</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem/" target="_blank" rel="noopener">1233. 删除子文件夹</a></td><td><a href="https://ferrerobomb.github.io/2022/01/09/leetcode-1233. 删除子文件夹/">leetcode-1233. 删除子文件夹</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/" target="_blank" rel="noopener">1342. 将数字变成 0 的操作次数</a></td><td><a href="https://ferrerobomb.github.io/2022/01/11/leetcode-1342.将数字变成0的操作次数/">leetcode-1342.将数字变成0的操作次数</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-of-matches-in-tournament/" target="_blank" rel="noopener">1688. 比赛中的配对次数</a></td><td><a href="https://ferrerobomb.github.io/2022/01/25/leetcode-1688-比赛中的配对次数/">leetcode-1688-比赛中的配对次数</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/" target="_blank" rel="noopener">2016. 增量元素之间的最大差值</a></td><td><a href="https://ferrerobomb.github.io/2022/02/25/leetcode-2016. 增量元素之间的最大差值/">leetcode-2016. 增量元素之间的最大差值</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/" target="_blank" rel="noopener">2124. 检查是否所有 A 都在 B 之前</a></td><td><a href="https://ferrerobomb.github.io/2022/01/12/leetcode-2124.检查是否所有A都在B之前/">leetcode-2124.检查是否所有A都在B之前</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/keep-multiplying-found-values-by-two/" target="_blank" rel="noopener">2154. 将找到的值乘以 2</a></td><td><a href="https://ferrerobomb.github.io/2022/01/31/leetcode-2154.将找到的值乘以2/">leetcode-2154.将找到的值乘以2</a></td></tr><tr><td>面试题30</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></td><td><a href="https://ferrerobomb.github.io/2020/02/25/leetcode-面试题32-II-从上到下打印二叉树II/">leetcode-面试题32-II-从上到下打印二叉树II</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></td><td><a href="https://ferrerobomb.github.io/2020/02/18/leetcode-面试题32-III-从上到下打印二叉树III/">leetcode-面试题32-III-从上到下打印二叉树III</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树</a></td><td><a href="https://ferrerobomb.github.io/2020/02/17/leetcode-面试题37-序列化二叉树/">leetcode-面试题37-序列化二叉树</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - II. 平衡二叉树</a></td><td><a href="https://ferrerobomb.github.io/2020/02/15/leetcode-面试题30-包含min函数的栈/">leetcode-面试题55-II-平衡二叉树</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 67. 把字符串转换成整数</a></td><td><a href="https://ferrerobomb.github.io/2020/02/19/leetcode-面试题67-把字符串转换成整数/">leetcode-面试题67-把字符串转换成整数</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></td><td><a href="https://ferrerobomb.github.io/2020/02/24/leetcode-面试题68-I二叉搜索树的最近公共祖先/">leetcode-面试题68-I二叉搜索树的最近公共祖先</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></td><td><a href="https://ferrerobomb.github.io/2020/02/19/leetcode-面试题68-II二叉树的最近公共祖先/">leetcode-面试题68 - II. 二叉树的最近公共祖先</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/SsGoHC/" target="_blank" rel="noopener">剑指 Offer II 074. 合并区间</a></td><td><a href="https://ferrerobomb.github.io/2022/01/10/leetcode-剑指 Offer II 074. 合并区间/">leetcode-剑指 Offer II 074. 合并区间</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/" target="_blank" rel="noopener">面试题 01.04. 回文排列</a></td><td><a href="https://ferrerobomb.github.io/2022/01/25/leetcode-面试题01-04-回文排列/">leetcode-面试题01.04.回文排列</a></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-35. 搜索插入位置</title>
    <link href="https://ferrerobomb.github.io/2022/02/27/leetcode-35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>https://ferrerobomb.github.io/2022/02/27/leetcode-35. 搜索插入位置/</id>
    <published>2022-02-27T07:39:32.000Z</published>
    <updated>2022-02-27T07:39:33.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-35-搜索插入位置"><a href="#leetcode-35-搜索插入位置" class="headerlink" title="leetcode-35. 搜索插入位置"></a>leetcode-35. 搜索插入位置</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>示例 1:</p><p>输入: nums = [1,3,5,6], target = 5<br>输出: 2<br>示例 2:</p><p>输入: nums = [1,3,5,6], target = 2<br>输出: 1<br>示例 3:</p><p>输入: nums = [1,3,5,6], target = 7<br>输出: 4<br>示例 4:</p><p>输入: nums = [1,3,5,6], target = 0<br>输出: 0<br>示例 5:</p><p>输入: nums = [1], target = 0<br>输出: 0</p><p>提示:</p><p>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 为无重复元素的升序排列数组<br>-104 &lt;= target &lt;= 104</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/search-insert-position" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debugger</span></span><br><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="comment">// 二分查找</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>, res = len;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// let mid = Math.floor((right - left) / 2) + left;</span></span><br><span class="line">    <span class="comment">// (right - left) &gt;&gt; 1 位运算右移一位， 等于Math.floor((right - left) / 2)</span></span><br><span class="line">    <span class="keyword">let</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left; </span><br><span class="line">    <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">      res = mid;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(searchInsert([1,3,5,6], 5));</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-98. 验证二叉搜索树</title>
    <link href="https://ferrerobomb.github.io/2022/02/26/leetcode-98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://ferrerobomb.github.io/2022/02/26/leetcode-98. 验证二叉搜索树/</id>
    <published>2022-02-26T03:39:45.000Z</published>
    <updated>2022-02-26T03:39:58.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-98-验证二叉搜索树"><a href="#leetcode-98-验证二叉搜索树" class="headerlink" title="leetcode-98. 验证二叉搜索树"></a>leetcode-98. 验证二叉搜索树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：</p><p>输入：root = [2,1,3]<br>输出：true<br>示例 2：</p><p>输入：root = [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。</p><p>提示：</p><p>树中节点数目范围在[1, 104] 内<br>-231 &lt;= Node.val &lt;= 231 - 1</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tmpValue = -<span class="literal">Infinity</span></span><br><span class="line">  <span class="keyword">let</span> valid = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || !valid) <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)</span><br><span class="line">    <span class="comment">// 核心思路，二叉搜索树中序遍历得到的一定是升序集合，所以判断是否为升序即可</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= tmpValue) &#123;</span><br><span class="line">      valid = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmpValue = root.val</span><br><span class="line">    dfs(root.right)</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(root)</span><br><span class="line">  <span class="keyword">return</span> valid;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-2016. 增量元素之间的最大差值</title>
    <link href="https://ferrerobomb.github.io/2022/02/25/leetcode-2016.%20%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
    <id>https://ferrerobomb.github.io/2022/02/25/leetcode-2016. 增量元素之间的最大差值/</id>
    <published>2022-02-25T10:00:08.000Z</published>
    <updated>2022-02-26T10:00:14.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-2016-增量元素之间的最大差值"><a href="#leetcode-2016-增量元素之间的最大差值" class="headerlink" title="leetcode-2016. 增量元素之间的最大差值"></a>leetcode-2016. 增量元素之间的最大差值</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 &lt;= i &lt; j &lt; n 且 nums[i] &lt; nums[j] 。</p><p>返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。</p><p>示例 1：</p><p>输入：nums = [7,1,5,4]<br>输出：4<br>解释：<br>最大差值出现在 i = 1 且 j = 2 时，nums[j] - nums[i] = 5 - 1 = 4 。<br>注意，尽管 i = 1 且 j = 0 时 ，nums[j] - nums[i] = 7 - 1 = 6 &gt; 4 ，但 i &gt; j 不满足题面要求，所以 6 不是有效的答案。<br>示例 2：</p><p>输入：nums = [9,4,3,2]<br>输出：-1<br>解释：<br>不存在同时满足 i &lt; j 和 nums[i] &lt; nums[j] 这两个条件的 i, j 组合。<br>示例 3：</p><p>输入：nums = [1,5,2,10]<br>输出：9<br>解释：<br>最大差值出现在 i = 0 且 j = 3 时，nums[j] - nums[i] = 10 - 1 = 9 。</p><p>提示：</p><p>n == nums.length<br>2 &lt;= n &lt;= 1000<br>1 &lt;= nums[i] &lt;= 109</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debugger</span></span><br><span class="line"><span class="comment">// 重点： 0 &lt;= i &lt; j &lt; n 且 nums[i] &lt; nums[j] 所以暂存最小值之后不用考虑前面的最小值。想象：前面的值比我暂存的最小值大，所以后面如果有符合要求最大区间的数，那么一定是和我当前的最小值组成的</span></span><br><span class="line"><span class="keyword">var</span> maximumDifference = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxDiff = <span class="number">0</span> <span class="comment">// 最大差值</span></span><br><span class="line">  <span class="keyword">let</span> min = <span class="literal">Infinity</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    maxDiff = <span class="built_in">Math</span>.max(maxDiff, num - min)</span><br><span class="line">    min = <span class="built_in">Math</span>.min(min, num)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxDiff &gt; <span class="number">0</span> ? maxDiff : <span class="number">-1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(maximumDifference([7,1,5,4]));</span></span><br><span class="line"><span class="comment">// console.log(maximumDifference([7,2,5,1,3]));</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-17. 电话号码的字母组合</title>
    <link href="https://ferrerobomb.github.io/2022/02/24/leetcode-17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>https://ferrerobomb.github.io/2022/02/24/leetcode-17. 电话号码的字母组合/</id>
    <published>2022-02-24T04:39:15.000Z</published>
    <updated>2022-02-24T04:48:34.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-17-电话号码的字母组合"><a href="#leetcode-17-电话号码的字母组合" class="headerlink" title="leetcode-17. 电话号码的字母组合"></a>leetcode-17. 电话号码的字母组合</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>示例 1：</p><p>输入：digits = “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p><p>输入：digits = “”<br>输出：[]<br>示例 3：</p><p>输入：digits = “2”<br>输出：[“a”,”b”,”c”]</p><p>提示：</p><p>0 &lt;= digits.length &lt;= 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1-回溯"><a href="#解1-回溯" class="headerlink" title="解1 回溯"></a>解1 回溯</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; digits</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// debugger</span></span><br><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 0 &lt;= digits.length &lt;= 4</span></span><br><span class="line">  <span class="keyword">const</span> len = digits.length</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dict = &#123;</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'abc'</span>,</span><br><span class="line">    <span class="string">'3'</span>: <span class="string">'def'</span>,</span><br><span class="line">    <span class="string">'4'</span>: <span class="string">'ghi'</span>,</span><br><span class="line">    <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">    <span class="string">'6'</span>: <span class="string">'mno'</span>,</span><br><span class="line">    <span class="string">'7'</span>: <span class="string">'pqrs'</span>,</span><br><span class="line">    <span class="string">'8'</span>: <span class="string">'tuv'</span>,</span><br><span class="line">    <span class="string">'9'</span>: <span class="string">'wxyz'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, digit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!digit.length) &#123;</span><br><span class="line">      res.push(str)</span><br><span class="line">      <span class="comment">// console.log(res);</span></span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentNumberStr = dict[digit[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currentNumberStr.length; i++) &#123;</span><br><span class="line">      str += currentNumberStr[i]</span><br><span class="line">      <span class="comment">// 递归</span></span><br><span class="line">      dfs(str, digit.slice(<span class="number">1</span>))</span><br><span class="line">      <span class="comment">// dfs(str, digits = digits.substring(1))</span></span><br><span class="line">      <span class="comment">// 回溯</span></span><br><span class="line">      str = str.slice(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  dfs(<span class="string">""</span>, digits);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(letterCombinations(<span class="string">'23'</span>));</span><br></pre></td></tr></table></figure><h2 id="解2-回溯使用map"><a href="#解2-回溯使用map" class="headerlink" title="解2 回溯使用map"></a>解2 回溯使用map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; digits</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// debugger</span></span><br><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 0 &lt;= digits.length &lt;= 4</span></span><br><span class="line">  <span class="keyword">const</span> len = digits.length</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'2'</span>, <span class="string">'abc'</span>],</span><br><span class="line">    [<span class="string">'3'</span>, <span class="string">'def'</span>],</span><br><span class="line">    [<span class="string">'4'</span>, <span class="string">'ghi'</span>],</span><br><span class="line">    [<span class="string">'5'</span>, <span class="string">'jkl'</span>],</span><br><span class="line">    [<span class="string">'6'</span>, <span class="string">'mno'</span>],</span><br><span class="line">    [<span class="string">'7'</span>, <span class="string">'pqrs'</span>],</span><br><span class="line">    [<span class="string">'8'</span>, <span class="string">'tuv'</span>],</span><br><span class="line">    [<span class="string">'9'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line">  ])</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, digit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!digit.length) &#123;</span><br><span class="line">      res.push(str)</span><br><span class="line">      <span class="comment">// console.log(res);</span></span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentNumberStr = dict.get(digit[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; currentNumberStr.length; i++) &#123;</span><br><span class="line">      str += currentNumberStr[i]</span><br><span class="line">      <span class="comment">// 递归</span></span><br><span class="line">      dfs(str, digit.slice(<span class="number">1</span>))</span><br><span class="line">      <span class="comment">// dfs(str, digits = digits.substring(1))</span></span><br><span class="line">      <span class="comment">// 回溯</span></span><br><span class="line">      str = str.slice(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  dfs(<span class="string">""</span>, digits);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(letterCombinations(<span class="string">'23'</span>));</span><br></pre></td></tr></table></figure><h2 id="解3-直接法"><a href="#解3-直接法" class="headerlink" title="解3 直接法"></a>解3 直接法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; digits</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// debugger</span></span><br><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 0 &lt;= digits.length &lt;= 4</span></span><br><span class="line">  <span class="keyword">const</span> len = digits.length</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">if</span> (!len) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dict = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'2'</span>, <span class="string">'abc'</span>],</span><br><span class="line">    [<span class="string">'3'</span>, <span class="string">'def'</span>],</span><br><span class="line">    [<span class="string">'4'</span>, <span class="string">'ghi'</span>],</span><br><span class="line">    [<span class="string">'5'</span>, <span class="string">'jkl'</span>],</span><br><span class="line">    [<span class="string">'6'</span>, <span class="string">'mno'</span>],</span><br><span class="line">    [<span class="string">'7'</span>, <span class="string">'pqrs'</span>],</span><br><span class="line">    [<span class="string">'8'</span>, <span class="string">'tuv'</span>],</span><br><span class="line">    [<span class="string">'9'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line">  ])</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">str, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index === digits.length) &#123;</span><br><span class="line">      res.push(str)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> dict.get(digits[index])) &#123;</span><br><span class="line">      dfs(str + char, index + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="string">''</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(letterCombinations(<span class="string">'23'</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-43. 字符串相乘</title>
    <link href="https://ferrerobomb.github.io/2022/02/23/leetcode-43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <id>https://ferrerobomb.github.io/2022/02/23/leetcode-43. 字符串相乘/</id>
    <published>2022-02-23T07:42:03.000Z</published>
    <updated>2022-02-24T07:42:08.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-43-字符串相乘"><a href="#leetcode-43-字符串相乘" class="headerlink" title="leetcode-43. 字符串相乘"></a>leetcode-43. 字符串相乘</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><p>示例 1:</p><p>输入: num1 = “2”, num2 = “3”<br>输出: “6”<br>示例 2:</p><p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p><p>提示：</p><p>1 &lt;= num1.length, num2.length &lt;= 200<br>num1 和 num2 只能由数字组成。<br>num1 和 num2 都不包含任何前导零，除了数字0本身。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/multiply-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/multiply-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; num1</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; num2</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> multiply = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不考虑数据错误</span></span><br><span class="line">  <span class="comment">// 处理0</span></span><br><span class="line">  <span class="keyword">if</span> (num1 === <span class="string">'0'</span> || num2 === <span class="string">'0'</span>) <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="comment">// 模拟乘法竖式运算</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = num1.length <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = num2.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="comment">// 核心思路，计算num1[i]*num1[j]反应到结果数字上只与第i + j位和i + j + 1位相关</span></span><br><span class="line">      <span class="keyword">let</span> carryPos = i + j; <span class="comment">// 进位位</span></span><br><span class="line">      <span class="keyword">let</span> productPos = i + j + <span class="number">1</span>; <span class="comment">// 乘积位</span></span><br><span class="line">      <span class="comment">// 计算。注意res[productPos]为上一步计算得到的进位，即上一轮循环的第20行res[carryPos]，需要运用到此轮乘积相加中</span></span><br><span class="line">      <span class="keyword">let</span> product = num1[i] * num2[j] + (res[productPos] || <span class="number">0</span>);</span><br><span class="line">      <span class="comment">// 此轮计算结束，处理此轮计算之后的乘积和进位</span></span><br><span class="line">      res[productPos] = product % <span class="number">10</span>;</span><br><span class="line">      <span class="comment">// 核心代码，由于乘法竖式运算很长，之前行上该列的运算结果也需要作为进位进入到当前行的运算。</span></span><br><span class="line">      res[carryPos] = <span class="built_in">Math</span>.floor(product / <span class="number">10</span>) + (res[carryPos] || <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">''</span>).replace(<span class="regexp">/^0+/</span>, <span class="string">''</span>); <span class="comment">// 开头如果有0 就去掉 处理个别最终位数有出入的情况</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="string">'2'</span>,<span class="string">'3'</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-100. 相同的树</title>
    <link href="https://ferrerobomb.github.io/2022/02/22/leetcode-100.%20%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
    <id>https://ferrerobomb.github.io/2022/02/22/leetcode-100. 相同的树/</id>
    <published>2022-02-22T08:19:45.000Z</published>
    <updated>2022-02-24T08:20:23.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-100-相同的树"><a href="#leetcode-100-相同的树" class="headerlink" title="leetcode-100. 相同的树"></a>leetcode-100. 相同的树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1：</p><p>输入：p = [1,2,3], q = [1,2,3]<br>输出：true<br>示例 2：</p><p>输入：p = [1,2], q = [1,null,2]<br>输出：false<br>示例 3：</p><p>输入：p = [1,2,1], q = [1,1,2]<br>输出：false</p><p>提示：</p><p>两棵树上的节点数目都在范围 [0, 100] 内<br>-104 &lt;= Node.val &lt;= 104</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/same-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; p</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; q</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? [root.val, ...dfs(root.left), ...dfs(root.right)] : [<span class="string">'null'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dfs(p).join(<span class="string">''</span>) === dfs(q).join(<span class="string">''</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-838. 推多米诺</title>
    <link href="https://ferrerobomb.github.io/2022/02/21/leetcode-838.%20%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/"/>
    <id>https://ferrerobomb.github.io/2022/02/21/leetcode-838. 推多米诺/</id>
    <published>2022-02-21T11:13:23.000Z</published>
    <updated>2022-02-21T11:13:51.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-838-推多米诺"><a href="#leetcode-838-推多米诺" class="headerlink" title="leetcode-838. 推多米诺"></a>leetcode-838. 推多米诺</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。</p><p>每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。</p><p>如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。</p><p>就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。</p><p>给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中：</p><p>dominoes[i] = ‘L’，表示第 i 张多米诺骨牌被推向左侧，<br>dominoes[i] = ‘R’，表示第 i 张多米诺骨牌被推向右侧，<br>dominoes[i] = ‘.’，表示没有推动第 i 张多米诺骨牌。<br>返回表示最终状态的字符串。</p><p>示例 1：</p><p>输入：dominoes = “RR.L”<br>输出：”RR.L”<br>解释：第一张多米诺骨牌没有给第二张施加额外的力。<br>示例 2：</p><p>输入：dominoes = “.L.R…LR..L..”<br>输出：”LL.RR.LLRRLL..”</p><p>提示：</p><p>n == dominoes.length<br>1 &lt;= n &lt;= 105<br>dominoes[i] 为 ‘L’、’R’ 或 ‘.’</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/push-dominoes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/push-dominoes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pushDominoes = <span class="function"><span class="keyword">function</span>(<span class="params">dominoes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只要骨牌没推完就继续推</span></span><br><span class="line">  <span class="keyword">while</span>(dominoes.includes(<span class="string">"R."</span>) || dominoes.includes(<span class="string">".L"</span>))&#123;;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      一共有6中情况</span></span><br><span class="line"><span class="comment">      此算法只需处理2中情况</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 在一次循环中，同一单元最多推一次</span></span><br><span class="line">    <span class="comment">// 先将R.L这种情况去掉</span></span><br><span class="line">    dominoes = dominoes.replaceAll(<span class="string">"R.L"</span>,<span class="string">"-"</span>)</span><br><span class="line">    <span class="comment">// 然后开始推骨牌,一次循环即在一秒钟内推一次，只有以下两种情况</span></span><br><span class="line">    dominoes = dominoes.replaceAll(<span class="string">"R."</span>,<span class="string">"RR"</span>).replaceAll(<span class="string">".L"</span>,<span class="string">"LL"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 推完之后再将R.L情况还原</span></span><br><span class="line">  <span class="keyword">return</span> dominoes.replaceAll(<span class="string">"-"</span>,<span class="string">"R.L"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-136.只出现一次的数字</title>
    <link href="https://ferrerobomb.github.io/2022/02/20/leetcode-136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://ferrerobomb.github.io/2022/02/20/leetcode-136.只出现一次的数字/</id>
    <published>2022-02-20T03:51:22.000Z</published>
    <updated>2022-02-20T03:51:45.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-136-只出现一次的数字"><a href="#leetcode-136-只出现一次的数字" class="headerlink" title="leetcode-136.只出现一次的数字"></a>leetcode-136.只出现一次的数字</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1-位异或"><a href="#解1-位异或" class="headerlink" title="解1 位异或"></a>解1 位异或</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        res ^= num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-21.合并两个有序链表</title>
    <link href="https://ferrerobomb.github.io/2022/02/19/leetcode-21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://ferrerobomb.github.io/2022/02/19/leetcode-21.合并两个有序链表/</id>
    <published>2022-02-19T14:28:13.000Z</published>
    <updated>2022-02-19T14:31:30.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-21-合并两个有序链表"><a href="#leetcode-21-合并两个有序链表" class="headerlink" title="leetcode-21.合并两个有序链表"></a>leetcode-21.合并两个有序链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例 1：</p><p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]<br>示例 2：</p><p>输入：l1 = [], l2 = []<br>输出：[]<br>示例 3：</p><p>输入：l1 = [], l2 = [0]<br>输出：[0]</p><p>提示：</p><p>两个链表的节点数目范围是 [0, 50]<br>-100 &lt;= Node.val &lt;= 100<br>l1 和 l2 均按 非递减顺序 排列</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1-迭代法"><a href="#解1-迭代法" class="headerlink" title="解1 迭代法"></a>解1 迭代法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; list1</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; list2</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> ListNode(<span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">let</span> p = res; <span class="comment">// 定义一个指针p指向res，用于操作新的listNode</span></span><br><span class="line">  <span class="keyword">while</span>(list1 &amp;&amp; list2) &#123;</span><br><span class="line">    <span class="comment">// 比较当前两个list.val大小，并填入新list，同时向后移动对应指针</span></span><br><span class="line">    <span class="keyword">if</span> (list1.val &gt;= list2.val) &#123;</span><br><span class="line">        p.next = list2</span><br><span class="line">        list2 = list2.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p.next = list1</span><br><span class="line">        list1 = list1.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动p以进行下一次循环</span></span><br><span class="line">    p = p.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时list1或list2至少有一个为null,连接另一个不为null的list即可</span></span><br><span class="line">  <span class="keyword">if</span> (list1) &#123;</span><br><span class="line">    p.next = list1</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2) &#123;</span><br><span class="line">    p.next = list2</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解2-递归法"><a href="#解2-递归法" class="headerlink" title="解2 递归法"></a>解2 递归法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; list1</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; list2</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">list1, list2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度与空间复杂度</title>
    <link href="https://ferrerobomb.github.io/2022/02/19/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://ferrerobomb.github.io/2022/02/19/时间复杂度与空间复杂度/</id>
    <published>2022-02-19T08:35:14.000Z</published>
    <updated>2022-02-19T09:13:48.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h1><p>1.</p><p>常数操作【执行时间固定的操作】：加减乘除等算术运算。位运算。赋值，比较，数组寻址等如let a = arr[8]</p><p>非常数操作【执行时间不固定的操作】：链表查询指定元素，数组遍历</p><p>2.</p><p>时间复杂度：只取计算时复杂度的最高阶项，且去掉系数。</p><p>如常见的选择排序：数组中有n项，复杂度为【证明过程略】<br>$$<br>an^2+bn+c<br>$$<br>时间复杂度为<br>$$<br>O(n^2)<br>$$<br>big-O表示的是上界。</p><p>时间复杂度越小的算法越好。时间复杂度相等的时候比较低阶项和常数项，不太好比较所以只能看实际情况区分算法好坏</p><p>3.</p><p>空间复杂度 ：算法在计算过程中额外占用的存储空间大小(除了计算数据本身需要额外开辟的空间)</p><p>4.</p><ul><li>稳定排序</li></ul><p>冒泡排序：时间复杂度O(n<sup>2</sup>)，空间复杂度O(1)</p><ul><li>不稳定排序</li></ul><p>选择排序：时间复杂度O(n<sup>2</sup>)，空间复杂度O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode-206.反转链表</title>
    <link href="https://ferrerobomb.github.io/2022/02/18/leetcode-206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://ferrerobomb.github.io/2022/02/18/leetcode-206.反转链表/</id>
    <published>2022-02-18T12:39:00.000Z</published>
    <updated>2022-02-18T12:43:42.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-206-反转链表"><a href="#leetcode-206-反转链表" class="headerlink" title="leetcode-206.反转链表"></a>leetcode-206.反转链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p><p>输入：head = [1,2]<br>输出：[2,1]<br>示例 3：</p><p>输入：head = []<br>输出：[]</p><p>提示：</p><p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;= Node.val &lt;= 5000</p><p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过定义两个指针，重新定义节点指向</span></span><br><span class="line">    <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> currentNode = head; <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="comment">// 如果链表没有结束【当前节点存在】 则遍历</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">        <span class="comment">// 临时指针next，用于存储临时的currentNode.next，想象：把下一个节点先存起来</span></span><br><span class="line">        <span class="keyword">const</span> next = currentNode.next;</span><br><span class="line">        <span class="comment">// currentNode.next指向previousNode， 想象：当前节点next指向前一个节点</span></span><br><span class="line">        currentNode.next = previousNode;</span><br><span class="line">        <span class="comment">// previousNode指向currentNode， 当前节点变为下一轮的前一个节点</span></span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        <span class="comment">// currentNode指向next， next存储的节点变为下一轮的当前节点</span></span><br><span class="line">        currentNode = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> previousNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-429.N叉树的层序遍历</title>
    <link href="https://ferrerobomb.github.io/2022/02/17/leetcode-429.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://ferrerobomb.github.io/2022/02/17/leetcode-429.N叉树的层序遍历/</id>
    <published>2022-02-17T14:01:47.000Z</published>
    <updated>2022-02-18T14:01:50.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-429-N叉树的层序遍历"><a href="#leetcode-429-N叉树的层序遍历" class="headerlink" title="leetcode-429.N叉树的层序遍历"></a>leetcode-429.N叉树的层序遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p>示例 1：</p><p>输入：root = [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]<br>示例 2：</p><p>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</p><p>提示：</p><p>树的高度不会超过 1000<br>树的节点总数在 [0, 10^4] 之间</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> ret = [];</span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length; <span class="comment">// 很关键， queue会变</span></span><br><span class="line">        ret.push([])</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            ret[ret.length - <span class="number">1</span>].push(node.val);</span><br><span class="line">            queue.push(...node.children);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-559.N叉树的最大深度</title>
    <link href="https://ferrerobomb.github.io/2022/02/16/leetcode-559.N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://ferrerobomb.github.io/2022/02/16/leetcode-559.N叉树的最大深度/</id>
    <published>2022-02-16T04:23:41.000Z</published>
    <updated>2022-02-19T07:46:05.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-559-N叉树的最大深度"><a href="#leetcode-559-N叉树的最大深度" class="headerlink" title="leetcode-559.N叉树的最大深度"></a>leetcode-559.N叉树的最大深度</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><p>示例 1：</p><p>输入：root = [1,null,3,2,4,null,5,6]<br>输出：3<br>示例 2：</p><p>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：5</p><p>提示：</p><p>树的深度不会超过 1000 。<br>树的节点数目位于 [0, 104] 之间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> child <span class="keyword">of</span> root.children) &#123;</span><br><span class="line">        res = <span class="built_in">Math</span>.max(res, maxDepth(child))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解2-时间快一点"><a href="#解2-时间快一点" class="headerlink" title="解2 时间快一点"></a>解2 时间快一点</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">treeDepth</span>(<span class="params">root,depth</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        depth++</span><br><span class="line">        max = <span class="built_in">Math</span>.max(depth,max)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> node <span class="keyword">of</span> root.children)&#123;</span><br><span class="line">            treeDepth(node,depth)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    treeDepth(root,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-590.N叉树的后序遍历</title>
    <link href="https://ferrerobomb.github.io/2022/02/15/leetcode-590.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://ferrerobomb.github.io/2022/02/15/leetcode-590.N叉树的后序遍历/</id>
    <published>2022-02-15T02:52:19.000Z</published>
    <updated>2022-02-19T03:03:14.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-590-N叉树的后序遍历"><a href="#leetcode-590-N叉树的后序遍历" class="headerlink" title="leetcode-590.N叉树的后序遍历"></a>leetcode-590.N叉树的后序遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p><p>示例 1：</p><p>输入：root = [1,null,3,2,4,null,5,6]<br>输出：[5,6,3,2,4,1]<br>示例 2：</p><p>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]</p><p>提示：</p><p>节点总数在范围 [0, 104] 内<br>0 &lt;= Node.val &lt;= 104<br>n 叉树的高度小于或等于 1000</p><p>进阶：递归法很简单，你可以使用迭代法完成此题吗?</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1-递归法"><a href="#解1-递归法" class="headerlink" title="解1 递归法"></a>解1 递归法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? [...root.children.flatMap(<span class="function"><span class="params">child</span> =&gt;</span> postorder(child)), root.val] : []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解2-迭代法"><a href="#解2-迭代法" class="headerlink" title="解2 迭代法"></a>解2 迭代法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> queue = [root];</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = queue.pop();</span><br><span class="line">        node.children &amp;&amp; queue.push(...node.children)</span><br><span class="line">        res.unshift(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-222.完全二叉树的节点个数</title>
    <link href="https://ferrerobomb.github.io/2022/02/14/leetcode-222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
    <id>https://ferrerobomb.github.io/2022/02/14/leetcode-222.完全二叉树的节点个数/</id>
    <published>2022-02-14T07:56:20.000Z</published>
    <updated>2022-02-14T07:58:02.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-222-完全二叉树的节点个数"><a href="#leetcode-222-完全二叉树的节点个数" class="headerlink" title="leetcode-222.完全二叉树的节点个数"></a>leetcode-222.完全二叉树的节点个数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例 1：</p><p>输入：root = [1,2,3,4,5,6]<br>输出：6<br>示例 2：</p><p>输入：root = []<br>输出：0<br>示例 3：</p><p>输入：root = [1]<br>输出：1</p><p>提示：</p><p>树中节点的数目范围是[0, 5 <em> 104]<br>0 &lt;= Node.val &lt;= 5 </em> 104<br>题目数据保证输入的树是 完全二叉树</p><p>进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-complete-tree-nodes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1-深度优先"><a href="#解1-深度优先" class="headerlink" title="解1 深度优先"></a>解1 深度优先</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解2-广度优先"><a href="#解2-广度优先" class="headerlink" title="解2 广度优先"></a>解2 广度优先</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// //  广度优先遍历</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = [root]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = queue.shift()</span><br><span class="line">            num++</span><br><span class="line">            <span class="keyword">if</span> (node.left) queue.push(node.left) </span><br><span class="line">            <span class="keyword">if</span> (node.right) queue.push(node.right) </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-589.N叉树的前序遍历</title>
    <link href="https://ferrerobomb.github.io/2022/02/13/leetcode-589.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://ferrerobomb.github.io/2022/02/13/leetcode-589.N叉树的前序遍历/</id>
    <published>2022-02-13T14:39:44.000Z</published>
    <updated>2022-02-18T14:42:07.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-589-N叉树的前序遍历"><a href="#leetcode-589-N叉树的前序遍历" class="headerlink" title="leetcode-589.N叉树的前序遍历"></a>leetcode-589.N叉树的前序遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 n 叉树的根节点  root ，返回 其节点值的 前序遍历 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p><p>示例 1：</p><p>输入：root = [1,null,3,2,4,null,5,6]<br>输出：[1,3,5,6,2,4]<br>示例 2：</p><p>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]</p><p>提示：</p><p>节点总数在范围 [0, 104]内<br>0 &lt;= Node.val &lt;= 104<br>n 叉树的高度小于或等于 1000</p><p>进阶：递归法很简单，你可以使用迭代法完成此题吗?</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(root.val)</span><br><span class="line">    <span class="keyword">if</span> (root.children) &#123;</span><br><span class="line">        root.children.map(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">            preorder(child, res);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? [root.val, ...root.children.flatMap(<span class="function"><span class="params">child</span> =&gt;</span> preorder(child))] : []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-6.Z字形变换</title>
    <link href="https://ferrerobomb.github.io/2022/02/12/leetcode-6.Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>https://ferrerobomb.github.io/2022/02/12/leetcode-6.Z字形变换/</id>
    <published>2022-02-12T14:11:33.000Z</published>
    <updated>2022-02-12T14:11:35.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-6-Z字形变换"><a href="#leetcode-6-Z字形变换" class="headerlink" title="leetcode-6.Z字形变换"></a>leetcode-6.Z字形变换</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>示例 1：</p><p>输入：s = “PAYPALISHIRING”, numRows = 3<br>输出：”PAHNAPLSIIGYIR”<br>示例 2：<br>输入：s = “PAYPALISHIRING”, numRows = 4<br>输出：”PINALSIGYAHRPI”<br>解释：<br>P     I    N<br>A   L S  I G<br>Y A   H R<br>P     I<br>示例 3：</p><p>输入：s = “A”, numRows = 1<br>输出：”A”</p><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 由英文字母（小写和大写）、’,’ 和 ‘.’ 组成<br>1 &lt;= numRows &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zigzag-conversion" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zigzag-conversion</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; numRows</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convert = <span class="function"><span class="keyword">function</span>(<span class="params">s, numRows</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows == <span class="number">1</span>)  <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">const</span> len = s.length; </span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="string">''</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想象一个打字机，纵向逐个打印字符串</span></span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>; <span class="comment">// 初始打字机位置</span></span><br><span class="line">    <span class="keyword">let</span> isDown = <span class="literal">true</span>; <span class="comment">// 初始的打印方向为向下</span></span><br><span class="line">    <span class="comment">// 开始打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="comment">// 每打印一个字符 打字机位置移动一格，方向由isDown控制</span></span><br><span class="line">        arr[pos] += char</span><br><span class="line">        <span class="keyword">if</span>(isDown)&#123;</span><br><span class="line">            pos++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pos--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打字机触碰到边界，则向反方向移动</span></span><br><span class="line">        <span class="keyword">if</span>(pos === <span class="number">0</span>)&#123;</span><br><span class="line">            isDown = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos === numRows<span class="number">-1</span>)&#123;</span><br><span class="line">            isDown = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">let</span> ans = <span class="string">""</span>;</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">char</span> =&gt;</span> &#123;</span><br><span class="line">        ans += char</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-102.二叉树的层序遍历</title>
    <link href="https://ferrerobomb.github.io/2022/02/11/leetcode-102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://ferrerobomb.github.io/2022/02/11/leetcode-102.二叉树的层序遍历/</id>
    <published>2022-02-11T02:00:48.000Z</published>
    <updated>2022-02-11T02:03:05.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-102-二叉树的层序遍历"><a href="#leetcode-102-二叉树的层序遍历" class="headerlink" title="leetcode-102.二叉树的层序遍历"></a>leetcode-102.二叉树的层序遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p>示例 1：</p><p>输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p><p>输入：root = [1]<br>输出：[[1]]<br>示例 3：</p><p>输入：root = []<br>输出：[]</p><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;= Node.val &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个队列用于广搜</span></span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="comment">// 初始化队列，当前节点入队</span></span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 每次循环队列都会变化</span></span><br><span class="line">        <span class="keyword">const</span> currentQueueLength = queue.length;</span><br><span class="line">        <span class="comment">// 用数组的方式表示层序遍历</span></span><br><span class="line">        ret.push([]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= currentQueueLength; ++i) &#123;</span><br><span class="line">        <span class="comment">// 取出队列中第一个节点</span></span><br><span class="line">        <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">        <span class="comment">// 节点值进入结果数组，并且将左右子树入队</span></span><br><span class="line">        ret[ret.length - <span class="number">1</span>].push(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.left) queue.push(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right) queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-445.两数相加 II</title>
    <link href="https://ferrerobomb.github.io/2022/02/10/leetcode-445.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20II/"/>
    <id>https://ferrerobomb.github.io/2022/02/10/leetcode-445.两数相加 II/</id>
    <published>2022-02-10T03:38:18.000Z</published>
    <updated>2022-02-10T03:38:19.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-445-两数相加-II"><a href="#leetcode-445-两数相加-II" class="headerlink" title="leetcode-445.两数相加 II"></a>leetcode-445.两数相加 II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>示例1：</p><p>输入：l1 = [7,2,4,3], l2 = [5,6,4]<br>输出：[7,8,0,7]<br>示例2：</p><p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[8,0,7]<br>示例3：</p><p>输入：l1 = [0], l2 = [0]<br>输出：[0]</p><p>提示：</p><p>链表的长度范围为 [1, 100]<br>0 &lt;= node.val &lt;= 9<br>输入数据保证链表代表的数字无前导 0</p><p>进阶：如果输入链表不能翻转该如何解决？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l1</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l2</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个栈，栈的pop可以模拟加法操作，即从末尾开始计算</span></span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">let</span> stack2 = [];</span><br><span class="line">    <span class="comment">// 把两个链表入栈 </span></span><br><span class="line">    <span class="keyword">while</span>(l1 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        stack1.push(l1.val);</span><br><span class="line">        l1 = l1.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        stack2.push(l2.val);</span><br><span class="line">        l2 = l2.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义进位数carry，最终结果ans </span></span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 两个栈至少有一个不为空，或者进位数有值，都意味着没计算结束，继续循环</span></span><br><span class="line">    <span class="keyword">while</span>(stack1.length || stack2.length || carry !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没东西则置为0计算，有东西就从后面正常开始加法，出栈操作</span></span><br><span class="line">        <span class="keyword">let</span> a = stack1.length === <span class="number">0</span> ? <span class="number">0</span> : stack1.pop()</span><br><span class="line">        <span class="keyword">let</span> b = stack2.length === <span class="number">0</span> ? <span class="number">0</span> : stack2.pop()</span><br><span class="line">        <span class="comment">// 正常加法，计算当前位数值cur，注意此时的carry是上一轮计算出来的</span></span><br><span class="line">        <span class="keyword">let</span> cur = a + b + carry</span><br><span class="line">        <span class="comment">// 正常计算进位</span></span><br><span class="line">        carry = <span class="built_in">Math</span>.floor(cur / <span class="number">10</span>)</span><br><span class="line">        <span class="comment">// 如果大于10则取个位</span></span><br><span class="line">        cur %= <span class="number">10</span></span><br><span class="line">        <span class="comment">// 链表数据结构操作</span></span><br><span class="line">        <span class="keyword">let</span> curNode = <span class="keyword">new</span> ListNode(cur)</span><br><span class="line">        curNode.next = ans</span><br><span class="line">        ans = curNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>

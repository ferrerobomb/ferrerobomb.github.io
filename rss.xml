<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>橙柚养乐多的博客</title>
  
  <subtitle>记录与领悟</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="https://ferrerobomb.github.io/"/>
  <updated>2022-02-19T03:03:29.222Z</updated>
  <id>https://ferrerobomb.github.io/</id>
  
  <author>
    <name>橙柚养乐多</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode中国版目录</title>
    <link href="https://ferrerobomb.github.io/2099/02/19/leetcode%E4%B8%AD%E5%9B%BD%E7%89%88%E7%9B%AE%E5%BD%95/"/>
    <id>https://ferrerobomb.github.io/2099/02/19/leetcode中国版目录/</id>
    <published>2099-02-19T15:44:03.000Z</published>
    <updated>2022-02-19T03:03:29.222Z</updated>
    
    <content type="html"><![CDATA[<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><table><thead><tr><th>序号.题目.</th><th>题目.解法</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></td><td><a href="https://ferrerobomb.github.io/2022/01/20/leetcode-1.两数之和/">leetcode-1.两数之和</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></td><td><a href="https://ferrerobomb.github.io/2022/01/25/leetcode-2.两数相加/">leetcode-2.两数相加</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></td><td><a href="https://ferrerobomb.github.io/2022/01/28/leetcode-3.无重复字符的最长子串/">leetcode-3.无重复字符的最长子串</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-6.Z字形变换/">leetcode-6.Z字形变换</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. 回文数</a></td><td><a href="https://ferrerobomb.github.io/2022/02/04/leetcode-9.回文数/">leetcode-9.回文数</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-20-有效的括号/">leetcode-20.有效的括号</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></td><td><a href="https://ferrerobomb.github.io/2022/01/22/leetcode-22.括号生成/">leetcode-22.括号生成</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></td><td><a href="https://ferrerobomb.github.io/2022/01/14/leetcode-33.搜索旋转排序数组/">leetcode-33.搜索旋转排序数组</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子数组和</a></td><td><a href="https://ferrerobomb.github.io/2022/01/29/leetcode-53.最大子数组和/">leetcode-53. 最大子数组和</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-54-螺旋矩阵/">leetcode-54.螺旋矩阵</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></td><td><a href="https://ferrerobomb.github.io/2022/01/21/leetcode-62.不同路径/">leetcode-62.不同路径</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></td><td><a href="https://ferrerobomb.github.io/2022/01/24/leetcode-70.爬楼梯/">leetcode-70.爬楼梯</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></td><td><a href="https://ferrerobomb.github.io/2022/01/30/leetcode-75.颜色分类/">leetcode-75.颜色分类</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></td><td><a href="https://ferrerobomb.github.io/2022/02/08/leetcode-78.子集/">leetcode-78.子集</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></td><td><a href="https://ferrerobomb.github.io/2022/01/23/leetcode-79.单词搜索/">leetcode-79.单词搜索</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></td><td><a href="https://ferrerobomb.github.io/2022/02/01/leetcode-88.合并两个有序数组/">leetcode-88.合并两个有序数组</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></td><td><a href="https://ferrerobomb.github.io/2020/02/26/leetcode-94-144-145-二叉树的遍历/">解法地址</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></td><td><a href="https://ferrerobomb.github.io/2022/02/11/leetcode-102.二叉树的层序遍历/">leetcode-102.二叉树的层序遍历</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-118.杨辉三角/">leetcode-118.杨辉三角</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></td><td><a href="https://ferrerobomb.github.io/2020/02/26/leetcode-94-144-145-二叉树的遍历/">解法地址</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></td><td><a href="https://ferrerobomb.github.io/2020/02/26/leetcode-94-144-145-二叉树的遍历/">解法地址</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/compare-version-numbers/" target="_blank" rel="noopener">165. 比较版本号</a></td><td><a href="https://ferrerobomb.github.io/2022/02/07/leetcode-165.比较版本号/">leetcode-165.比较版本号</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener">168. Excel表列名称</a></td><td><a href="https://ferrerobomb.github.io/2022/01/31/leetcode-168.Excel表列名称/">leetcode-168.Excel表列名称</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">171. Excel 表列序号</a></td><td><a href="https://ferrerobomb.github.io/2022/02/03/leetcode-171.Excel 表列序号/">leetcode-171.Excel 表列序号</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/duplicate-emails/" target="_blank" rel="noopener">182. 查找重复的电子邮箱</a></td><td><a href="https://ferrerobomb.github.io/2022/02/02/leetcode-182.查找重复的电子邮箱/">leetcode-182.查找重复的电子邮箱</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/word-frequency/" target="_blank" rel="noopener">192. 统计词频</a></td><td><a href="https://ferrerobomb.github.io/2022/02/06/leetcode-192.统计词频/">leetcode-192.统计词频</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-198-打家劫舍/">leetcode-198.打家劫舍</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">283. 移动零</a></td><td><a href="https://ferrerobomb.github.io/2022/02/09/leetcode-283.移动零/">leetcode-283.移动零</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></td><td><a href="https://ferrerobomb.github.io/2022/01/26/leetcode-322-零钱兑换/">leetcode-322.零钱兑换</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/arithmetic-slices" target="_blank" rel="noopener">413. 等差数列划分</a></td><td><a href="https://ferrerobomb.github.io/2021/08/19/leetcode-413-等差数列划分/">leetcode-413.等差数列划分</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N 叉树的层序遍历</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a></td><td><a href="https://ferrerobomb.github.io/2022/02/10/leetcode-445.两数相加 II/">leetcode-445.两数相加 II</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence" target="_blank" rel="noopener">516. 最长回文子序列</a></td><td><a href="https://ferrerobomb.github.io/2021/08/19/leetcode-516-最长回文子序列/">leetcode-516.最长回文子序列</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N 叉树的后序遍历</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">912. 排序数组</a></td><td><a href="https://ferrerobomb.github.io/2022/01/13/leetcode-912.排序数组/">leetcode-912.排序数组</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/" target="_blank" rel="noopener">1342. 将数字变成 0 的操作次数</a></td><td><a href="https://ferrerobomb.github.io/2022/01/11/leetcode-1342.将数字变成0的操作次数/">leetcode-1342.将数字变成0的操作次数</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/count-of-matches-in-tournament/" target="_blank" rel="noopener">1688. 比赛中的配对次数</a></td><td><a href="https://ferrerobomb.github.io/2022/01/25/leetcode-1688-比赛中的配对次数/">leetcode-1688-比赛中的配对次数</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/" target="_blank" rel="noopener">2124. 检查是否所有 A 都在 B 之前</a></td><td><a href="https://ferrerobomb.github.io/2022/01/12/leetcode-2124.检查是否所有A都在B之前/">leetcode-2124.检查是否所有A都在B之前</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/keep-multiplying-found-values-by-two/" target="_blank" rel="noopener">2154. 将找到的值乘以 2</a></td><td><a href="https://ferrerobomb.github.io/2022/01/31/leetcode-2154.将找到的值乘以2/">leetcode-2154.将找到的值乘以2</a></td></tr><tr><td>面试题30</td><td><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof" target="_blank" rel="noopener">包含min函数的栈</a> <a href="https://ferrerobomb.github.io/2020/02/15/leetcode-面试题30-包含min函数的栈/">解法地址</a></td></tr><tr><td>面试题32 - II</td><td><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof" target="_blank" rel="noopener">从上到下打印二叉树 II</a> <a href="https://ferrerobomb.github.io/2020/02/25/leetcode-面试题32-II-从上到下打印二叉树II/">解法地址</a></td></tr><tr><td>面试题32 - III</td><td><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof" target="_blank" rel="noopener">从上到下打印二叉树 III</a> <a href="https://ferrerobomb.github.io/2020/02/18/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9832-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91III/">解法地址</a></td></tr><tr><td>面试题37</td><td><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof" target="_blank" rel="noopener">序列化二叉树</a> <a href="https://ferrerobomb.github.io/2020/02/17/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9837-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/">解法地址</a></td></tr><tr><td>面试题55 - II</td><td><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof" target="_blank" rel="noopener">平衡二叉树</a> <a href="https://ferrerobomb.github.io/2020/02/15/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9855-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">解法地址</a></td></tr><tr><td>面试题67</td><td>把字符串转换成整数 <a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank" rel="noopener">题目地址</a> <a href="https://ferrerobomb.github.io/2020/02/19/leetcode-面试题67-把字符串转换成整数/">解法地址</a></td></tr><tr><td>面试题68 - I</td><td>二叉搜索树的最近公共祖先 <a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/submissions/" target="_blank" rel="noopener">题目地址</a> <a href="https://ferrerobomb.github.io/2020/02/24/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9868-I%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">解法地址</a></td></tr><tr><td>面试题68 - II</td><td>二叉树的最近公共祖先 <a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">题目地址</a> <a href="https://ferrerobomb.github.io/2020/02/19/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9868-II%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">解法地址</a></td></tr><tr><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/" target="_blank" rel="noopener">面试题 01.04. 回文排列</a></td><td><a href="https://ferrerobomb.github.io/2022/01/25/leetcode-面试题01-04-回文排列/">leetcode-面试题01.04.回文排列</a></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-206.反转链表</title>
    <link href="https://ferrerobomb.github.io/2022/02/18/leetcode-206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://ferrerobomb.github.io/2022/02/18/leetcode-206.反转链表/</id>
    <published>2022-02-18T12:39:00.000Z</published>
    <updated>2022-02-18T12:43:42.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-206-反转链表"><a href="#leetcode-206-反转链表" class="headerlink" title="leetcode-206.反转链表"></a>leetcode-206.反转链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p><p>输入：head = [1,2]<br>输出：[2,1]<br>示例 3：</p><p>输入：head = []<br>输出：[]</p><p>提示：</p><p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;= Node.val &lt;= 5000</p><p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过定义两个指针，重新定义节点指向</span></span><br><span class="line">    <span class="keyword">let</span> previousNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> currentNode = head; <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="comment">// 如果链表没有结束【当前节点存在】 则遍历</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">        <span class="comment">// 临时指针next，用于存储临时的currentNode.next，想象：把下一个节点先存起来</span></span><br><span class="line">        <span class="keyword">const</span> next = currentNode.next;</span><br><span class="line">        <span class="comment">// currentNode.next指向previousNode， 想象：当前节点next指向前一个节点</span></span><br><span class="line">        currentNode.next = previousNode;</span><br><span class="line">        <span class="comment">// previousNode指向currentNode， 当前节点变为下一轮的前一个节点</span></span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        <span class="comment">// currentNode指向next， next存储的节点变为下一轮的当前节点</span></span><br><span class="line">        currentNode = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> previousNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-429.N叉树的层序遍历</title>
    <link href="https://ferrerobomb.github.io/2022/02/17/leetcode-429.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://ferrerobomb.github.io/2022/02/17/leetcode-429.N叉树的层序遍历/</id>
    <published>2022-02-17T14:01:47.000Z</published>
    <updated>2022-02-18T14:01:50.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-429-N叉树的层序遍历"><a href="#leetcode-429-N叉树的层序遍历" class="headerlink" title="leetcode-429.N叉树的层序遍历"></a>leetcode-429.N叉树的层序遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p>示例 1：</p><p>输入：root = [1,null,3,2,4,null,5,6]<br>输出：[[1],[3,2,4],[5,6]]<br>示例 2：</p><p>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</p><p>提示：</p><p>树的高度不会超过 1000<br>树的节点总数在 [0, 10^4] 之间</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> ret = [];</span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length; <span class="comment">// 很关键， queue会变</span></span><br><span class="line">        ret.push([])</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            ret[ret.length - <span class="number">1</span>].push(node.val);</span><br><span class="line">            queue.push(...node.children);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-590.N叉树的后序遍历</title>
    <link href="https://ferrerobomb.github.io/2022/02/15/leetcode-590.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://ferrerobomb.github.io/2022/02/15/leetcode-590.N叉树的后序遍历/</id>
    <published>2022-02-15T02:52:19.000Z</published>
    <updated>2022-02-19T03:03:14.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-590-N叉树的后序遍历"><a href="#leetcode-590-N叉树的后序遍历" class="headerlink" title="leetcode-590.N叉树的后序遍历"></a>leetcode-590.N叉树的后序遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p><p>示例 1：</p><p>输入：root = [1,null,3,2,4,null,5,6]<br>输出：[5,6,3,2,4,1]<br>示例 2：</p><p>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]</p><p>提示：</p><p>节点总数在范围 [0, 104] 内<br>0 &lt;= Node.val &lt;= 104<br>n 叉树的高度小于或等于 1000</p><p>进阶：递归法很简单，你可以使用迭代法完成此题吗?</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1-递归法"><a href="#解1-递归法" class="headerlink" title="解1 递归法"></a>解1 递归法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? [...root.children.flatMap(<span class="function"><span class="params">child</span> =&gt;</span> postorder(child)), root.val] : []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解2-迭代法"><a href="#解2-迭代法" class="headerlink" title="解2 迭代法"></a>解2 迭代法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val,children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">const</span> queue = [root];</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = queue.pop();</span><br><span class="line">        node.children &amp;&amp; queue.push(...node.children)</span><br><span class="line">        res.unshift(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-222.完全二叉树的节点个数</title>
    <link href="https://ferrerobomb.github.io/2022/02/14/leetcode-222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
    <id>https://ferrerobomb.github.io/2022/02/14/leetcode-222.完全二叉树的节点个数/</id>
    <published>2022-02-14T07:56:20.000Z</published>
    <updated>2022-02-14T07:58:02.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-222-完全二叉树的节点个数"><a href="#leetcode-222-完全二叉树的节点个数" class="headerlink" title="leetcode-222.完全二叉树的节点个数"></a>leetcode-222.完全二叉树的节点个数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例 1：</p><p>输入：root = [1,2,3,4,5,6]<br>输出：6<br>示例 2：</p><p>输入：root = []<br>输出：0<br>示例 3：</p><p>输入：root = [1]<br>输出：1</p><p>提示：</p><p>树中节点的数目范围是[0, 5 <em> 104]<br>0 &lt;= Node.val &lt;= 5 </em> 104<br>题目数据保证输入的树是 完全二叉树</p><p>进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-complete-tree-nodes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1-深度优先"><a href="#解1-深度优先" class="headerlink" title="解1 深度优先"></a>解1 深度优先</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解2-广度优先"><a href="#解2-广度优先" class="headerlink" title="解2 广度优先"></a>解2 广度优先</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// //  广度优先遍历</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> queue = [root]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = queue.shift()</span><br><span class="line">            num++</span><br><span class="line">            <span class="keyword">if</span> (node.left) queue.push(node.left) </span><br><span class="line">            <span class="keyword">if</span> (node.right) queue.push(node.right) </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-589.N叉树的前序遍历</title>
    <link href="https://ferrerobomb.github.io/2022/02/13/leetcode-589.N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://ferrerobomb.github.io/2022/02/13/leetcode-589.N叉树的前序遍历/</id>
    <published>2022-02-13T14:39:44.000Z</published>
    <updated>2022-02-18T14:42:07.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-589-N叉树的前序遍历"><a href="#leetcode-589-N叉树的前序遍历" class="headerlink" title="leetcode-589.N叉树的前序遍历"></a>leetcode-589.N叉树的前序遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 n 叉树的根节点  root ，返回 其节点值的 前序遍历 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p><p>示例 1：</p><p>输入：root = [1,null,3,2,4,null,5,6]<br>输出：[1,3,5,6,2,4]<br>示例 2：</p><p>输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]</p><p>提示：</p><p>节点总数在范围 [0, 104]内<br>0 &lt;= Node.val &lt;= 104<br>n 叉树的高度小于或等于 1000</p><p>进阶：递归法很简单，你可以使用迭代法完成此题吗?</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(root.val)</span><br><span class="line">    <span class="keyword">if</span> (root.children) &#123;</span><br><span class="line">        root.children.map(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">            preorder(child, res);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, children) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.children = children;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Node|null&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? [root.val, ...root.children.flatMap(<span class="function"><span class="params">child</span> =&gt;</span> preorder(child))] : []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-6.Z字形变换</title>
    <link href="https://ferrerobomb.github.io/2022/02/12/leetcode-6.Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>https://ferrerobomb.github.io/2022/02/12/leetcode-6.Z字形变换/</id>
    <published>2022-02-12T14:11:33.000Z</published>
    <updated>2022-02-12T14:11:35.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-6-Z字形变换"><a href="#leetcode-6-Z字形变换" class="headerlink" title="leetcode-6.Z字形变换"></a>leetcode-6.Z字形变换</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>示例 1：</p><p>输入：s = “PAYPALISHIRING”, numRows = 3<br>输出：”PAHNAPLSIIGYIR”<br>示例 2：<br>输入：s = “PAYPALISHIRING”, numRows = 4<br>输出：”PINALSIGYAHRPI”<br>解释：<br>P     I    N<br>A   L S  I G<br>Y A   H R<br>P     I<br>示例 3：</p><p>输入：s = “A”, numRows = 1<br>输出：”A”</p><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 由英文字母（小写和大写）、’,’ 和 ‘.’ 组成<br>1 &lt;= numRows &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zigzag-conversion" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zigzag-conversion</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; numRows</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convert = <span class="function"><span class="keyword">function</span>(<span class="params">s, numRows</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numRows == <span class="number">1</span>)  <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">const</span> len = s.length; </span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="string">''</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想象一个打字机，纵向逐个打印字符串</span></span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>; <span class="comment">// 初始打字机位置</span></span><br><span class="line">    <span class="keyword">let</span> isDown = <span class="literal">true</span>; <span class="comment">// 初始的打印方向为向下</span></span><br><span class="line">    <span class="comment">// 开始打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="comment">// 每打印一个字符 打字机位置移动一格，方向由isDown控制</span></span><br><span class="line">        arr[pos] += char</span><br><span class="line">        <span class="keyword">if</span>(isDown)&#123;</span><br><span class="line">            pos++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pos--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打字机触碰到边界，则向反方向移动</span></span><br><span class="line">        <span class="keyword">if</span>(pos === <span class="number">0</span>)&#123;</span><br><span class="line">            isDown = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos === numRows<span class="number">-1</span>)&#123;</span><br><span class="line">            isDown = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">let</span> ans = <span class="string">""</span>;</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">char</span> =&gt;</span> &#123;</span><br><span class="line">        ans += char</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-102.二叉树的层序遍历</title>
    <link href="https://ferrerobomb.github.io/2022/02/11/leetcode-102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://ferrerobomb.github.io/2022/02/11/leetcode-102.二叉树的层序遍历/</id>
    <published>2022-02-11T02:00:48.000Z</published>
    <updated>2022-02-11T02:03:05.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-102-二叉树的层序遍历"><a href="#leetcode-102-二叉树的层序遍历" class="headerlink" title="leetcode-102.二叉树的层序遍历"></a>leetcode-102.二叉树的层序遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p>示例 1：</p><p>输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p><p>输入：root = [1]<br>输出：[[1]]<br>示例 3：</p><p>输入：root = []<br>输出：[]</p><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;= Node.val &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个队列用于广搜</span></span><br><span class="line">    <span class="keyword">const</span> queue = [];</span><br><span class="line">    <span class="comment">// 初始化队列，当前节点入队</span></span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 每次循环队列都会变化</span></span><br><span class="line">        <span class="keyword">const</span> currentQueueLength = queue.length;</span><br><span class="line">        <span class="comment">// 用数组的方式表示层序遍历</span></span><br><span class="line">        ret.push([]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= currentQueueLength; ++i) &#123;</span><br><span class="line">        <span class="comment">// 取出队列中第一个节点</span></span><br><span class="line">        <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">        <span class="comment">// 节点值进入结果数组，并且将左右子树入队</span></span><br><span class="line">        ret[ret.length - <span class="number">1</span>].push(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.left) queue.push(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right) queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-445.两数相加 II</title>
    <link href="https://ferrerobomb.github.io/2022/02/10/leetcode-445.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20II/"/>
    <id>https://ferrerobomb.github.io/2022/02/10/leetcode-445.两数相加 II/</id>
    <published>2022-02-10T03:38:18.000Z</published>
    <updated>2022-02-10T03:38:19.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-445-两数相加-II"><a href="#leetcode-445-两数相加-II" class="headerlink" title="leetcode-445.两数相加 II"></a>leetcode-445.两数相加 II</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>示例1：</p><p>输入：l1 = [7,2,4,3], l2 = [5,6,4]<br>输出：[7,8,0,7]<br>示例2：</p><p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[8,0,7]<br>示例3：</p><p>输入：l1 = [0], l2 = [0]<br>输出：[0]</p><p>提示：</p><p>链表的长度范围为 [1, 100]<br>0 &lt;= node.val &lt;= 9<br>输入数据保证链表代表的数字无前导 0</p><p>进阶：如果输入链表不能翻转该如何解决？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l1</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; l2</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个栈，栈的pop可以模拟加法操作，即从末尾开始计算</span></span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">let</span> stack2 = [];</span><br><span class="line">    <span class="comment">// 把两个链表入栈 </span></span><br><span class="line">    <span class="keyword">while</span>(l1 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        stack1.push(l1.val);</span><br><span class="line">        l1 = l1.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        stack2.push(l2.val);</span><br><span class="line">        l2 = l2.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义进位数carry，最终结果ans </span></span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 两个栈至少有一个不为空，或者进位数有值，都意味着没计算结束，继续循环</span></span><br><span class="line">    <span class="keyword">while</span>(stack1.length || stack2.length || carry !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没东西则置为0计算，有东西就从后面正常开始加法，出栈操作</span></span><br><span class="line">        <span class="keyword">let</span> a = stack1.length === <span class="number">0</span> ? <span class="number">0</span> : stack1.pop()</span><br><span class="line">        <span class="keyword">let</span> b = stack2.length === <span class="number">0</span> ? <span class="number">0</span> : stack2.pop()</span><br><span class="line">        <span class="comment">// 正常加法，计算当前位数值cur，注意此时的carry是上一轮计算出来的</span></span><br><span class="line">        <span class="keyword">let</span> cur = a + b + carry</span><br><span class="line">        <span class="comment">// 正常计算进位</span></span><br><span class="line">        carry = <span class="built_in">Math</span>.floor(cur / <span class="number">10</span>)</span><br><span class="line">        <span class="comment">// 如果大于10则取个位</span></span><br><span class="line">        cur %= <span class="number">10</span></span><br><span class="line">        <span class="comment">// 链表数据结构操作</span></span><br><span class="line">        <span class="keyword">let</span> curNode = <span class="keyword">new</span> ListNode(cur)</span><br><span class="line">        curNode.next = ans</span><br><span class="line">        ans = curNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-283.移动零</title>
    <link href="https://ferrerobomb.github.io/2022/02/09/leetcode-283.%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>https://ferrerobomb.github.io/2022/02/09/leetcode-283.移动零/</id>
    <published>2022-02-09T12:16:48.000Z</published>
    <updated>2022-02-09T12:16:50.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-283-移动零"><a href="#leetcode-283-移动零" class="headerlink" title="leetcode-283.移动零"></a>leetcode-283.移动零</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1:</p><p>输入: nums = [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p><p>输入: nums = [0]<br>输出: [0]</p><p>提示:</p><p>1 &lt;= nums.length &lt;= 104<br>-231 &lt;= nums[i] &lt;= 231 - 1</p><p>进阶：你能尽量减少完成的操作次数吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/move-zeroes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[p1] != <span class="number">0</span>) &#123;</span><br><span class="line">            [nums[p1], nums[p2]] = [nums[p2], nums[p1]];</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        p1++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-78.子集</title>
    <link href="https://ferrerobomb.github.io/2022/02/08/leetcode-78.%E5%AD%90%E9%9B%86/"/>
    <id>https://ferrerobomb.github.io/2022/02/08/leetcode-78.子集/</id>
    <published>2022-02-08T02:50:49.000Z</published>
    <updated>2022-02-08T03:18:06.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-78-子集【二维数组】"><a href="#leetcode-78-子集【二维数组】" class="headerlink" title="leetcode-78.子集【二维数组】"></a>leetcode-78.子集【二维数组】</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><p>输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p><p>输入：nums = [0]<br>输出：[[],[0]]</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 10<br>-10 &lt;= nums[i] &lt;= 10<br>nums 中的所有元素 互不相同</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">if</span> (nums.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        result = [[], [nums[<span class="number">0</span>]]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> currentResult = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; result.length; k++) &#123;</span><br><span class="line">        currentResult.push([...result[k]])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// console.log(JSON.stringify(result), JSON.stringify(currentResult));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; currentResult.length; j++) &#123;</span><br><span class="line">        currentResult[j].push(nums[i])</span><br><span class="line">        <span class="comment">// console.log(JSON.stringify(result), JSON.stringify(currentResult));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// console.log(JSON.stringify(result), JSON.stringify(currentResult));</span></span><br><span class="line">        result = result.concat(currentResult)</span><br><span class="line">        <span class="comment">// console.log(JSON.stringify(result));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;</span><br><span class="line">        <span class="keyword">const</span> t = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                t.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解3-回溯"><a href="#解3-回溯" class="headerlink" title="解3 回溯"></a>解3 回溯</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">index, list</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">      <span class="comment">// 指针越界</span></span><br><span class="line">      res.push(list.slice()); <span class="comment">// 加入解集</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 结束当前的递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    list.push(nums[index]); <span class="comment">// 选择这个数</span></span><br><span class="line">    dfs(index + <span class="number">1</span>, list); <span class="comment">// 基于该选择，继续往下递归，考察下一个数</span></span><br><span class="line">    list.pop(); <span class="comment">// 上面的递归结束，撤销该选择</span></span><br><span class="line">    dfs(index + <span class="number">1</span>, list); <span class="comment">// 不选这个数，继续往下递归，考察下一个数</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-165.比较版本号</title>
    <link href="https://ferrerobomb.github.io/2022/02/07/leetcode-165.%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    <id>https://ferrerobomb.github.io/2022/02/07/leetcode-165.比较版本号/</id>
    <published>2022-02-07T01:57:23.000Z</published>
    <updated>2022-02-08T01:58:10.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-165-比较版本号"><a href="#leetcode-165-比较版本号" class="headerlink" title="leetcode-165.比较版本号"></a>leetcode-165.比较版本号</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p><p>示例 1：</p><p>输入：version1 = “1.01”, version2 = “1.001”<br>输出：0<br>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”<br>示例 2：</p><p>输入：version1 = “1.0”, version2 = “1.0.0”<br>输出：0<br>解释：version1 没有指定下标为 2 的修订号，即视为 “0”<br>示例 3：</p><p>输入：version1 = “0.1”, version2 = “1.1”<br>输出：-1<br>解释：version1 中下标为 0 的修订号是 “0”，version2 中下标为 0 的修订号是 “1” 。0 &lt; 1，所以 version1 &lt; version2</p><p>提示：</p><p>1 &lt;= version1.length, version2.length &lt;= 500<br>version1 和 version2 仅包含数字和 ‘.’<br>version1 和 version2 都是 有效版本号<br>version1 和 version2 的所有修订号都可以存储在 32 位整数 中</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/compare-version-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/compare-version-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; version1</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; version2</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> compareVersion = <span class="function"><span class="keyword">function</span>(<span class="params">version1, version2</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (version1 === version2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> version1Array = version1.split(<span class="string">'.'</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Number</span>(item));</span><br><span class="line">    <span class="keyword">let</span> version2Array = version2.split(<span class="string">'.'</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Number</span>(item));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; version1Array.length || i &lt; version2Array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; version1Array.length) &#123;</span><br><span class="line">            x = version1Array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; version2Array.length) &#123;</span><br><span class="line">            y = version2Array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-192.统计词频</title>
    <link href="https://ferrerobomb.github.io/2022/02/06/leetcode-192.%E7%BB%9F%E8%AE%A1%E8%AF%8D%E9%A2%91/"/>
    <id>https://ferrerobomb.github.io/2022/02/06/leetcode-192.统计词频/</id>
    <published>2022-02-06T01:02:44.000Z</published>
    <updated>2022-02-06T01:03:00.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-192-统计词频"><a href="#leetcode-192-统计词频" class="headerlink" title="leetcode-192.统计词频"></a>leetcode-192.统计词频</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。</p><p>为了简单起见，你可以假设：</p><p>words.txt只包括小写字母和 ‘ ‘ 。<br>每个单词只由小写字母组成。<br>单词间由一个或多个空格字符分隔。<br>示例:</p><p>假设 words.txt 内容如下：</p><p>the day is sunny the the<br>the sunny is is<br>你的脚本应当输出（以词频降序排列）：</p><p>the 4<br>is 3<br>sunny 2<br>day 1<br>说明:</p><p>不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。<br>你可以使用一行 Unix pipes 实现吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-frequency" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-frequency</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Read from the file words.txt and output the word frequency list to stdout.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://leetcode-cn.com/problems/word-frequency/solution/qie-ge-pai-xu-dan-ci-tong-ji-ci-shu-pai-8sdgt/</span></span><br><span class="line"></span><br><span class="line">cat words.txt | tr -s ' ' '\n' | sort | uniq -c | sort -r | awk '&#123; print $2, $1 &#125;'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解题步骤</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 切割</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tr 命令用于转换或删除文件中的字符</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -s：缩减连续重复的字符成指定的单个字符</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat Words.txt| tr -s <span class="string">' '</span> <span class="string">'\n'</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> day</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sunny</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sunny</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 排序单词</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat Words.txt| tr -s <span class="string">' '</span> <span class="string">'\n'</span> | sort</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> day</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sunny</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sunny</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 统计单词出现次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c：在每列旁边显示该行重复出现的次数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat Words.txt| tr -s <span class="string">' '</span> <span class="string">'\n'</span> | sort | uniq -c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 day</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 sunny</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 排序单词出现次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r：以相反的顺序来排序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat Words.txt| tr -s <span class="string">' '</span> <span class="string">'\n'</span> | sort | uniq -c | sort -r</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 sunny</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 day</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5 打印</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat Words.txt| tr -s <span class="string">' '</span> <span class="string">'\n'</span> | sort | uniq -c | sort -r | awk <span class="string">'&#123;print $2, $1&#125;'</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sunny 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> day 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-168.Excel表列名称</title>
    <link href="https://ferrerobomb.github.io/2022/02/05/leetcode-168.Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/"/>
    <id>https://ferrerobomb.github.io/2022/02/05/leetcode-168.Excel表列名称/</id>
    <published>2022-02-05T13:12:35.000Z</published>
    <updated>2022-02-06T00:54:46.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-168-Excel表列名称"><a href="#leetcode-168-Excel表列名称" class="headerlink" title="leetcode-168.Excel表列名称"></a>leetcode-168.Excel表列名称</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。</p><p>例如：</p><p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>…</p><p>示例 1：</p><p>输入：columnNumber = 1<br>输出：”A”<br>示例 2：</p><p>输入：columnNumber = 28<br>输出：”AB”<br>示例 3：</p><p>输入：columnNumber = 701<br>输出：”ZY”<br>示例 4：</p><p>输入：columnNumber = 2147483647<br>输出：”FXSHRXW”</p><p>提示：</p><p>1 &lt;= columnNumber &lt;= 231 - 1</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/excel-sheet-column-title" target="_blank" rel="noopener">https://leetcode-cn.com/problems/excel-sheet-column-title</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; columnNumber</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//  26进制 理解非10进制</span></span><br><span class="line"><span class="keyword">var</span> convertToTitle = <span class="function"><span class="keyword">function</span>(<span class="params">columnNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">while</span> (columnNumber != <span class="number">0</span>) &#123;</span><br><span class="line">columnNumber--; <span class="comment">// --之后就符合26进制的0-25了</span></span><br><span class="line">str += <span class="built_in">String</span>.fromCharCode(<span class="string">"A"</span>.charCodeAt() + (columnNumber % <span class="number">26</span>)); <span class="comment">// columnNumber % 26值为0-25，计算出A-Z</span></span><br><span class="line">columnNumber /= <span class="number">26</span>; <span class="comment">// 不用Math.floor是因为String.fromCharCode忽略小数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-9.回文数</title>
    <link href="https://ferrerobomb.github.io/2022/02/04/leetcode-9.%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>https://ferrerobomb.github.io/2022/02/04/leetcode-9.回文数/</id>
    <published>2022-02-04T11:11:43.000Z</published>
    <updated>2022-02-05T01:07:41.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-9-回文数"><a href="#leetcode-9-回文数" class="headerlink" title="leetcode-9.回文数"></a>leetcode-9.回文数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p><p>示例 1：</p><p>输入：x = 121<br>输出：true<br>示例 2：</p><p>输入：x = -121<br>输出：false<br>解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3：</p><p>输入：x = 10<br>输出：false<br>解释：从右向左读, 为 01 。因此它不是一个回文数。<br>示例 4：</p><p>输入：x = -101<br>输出：false</p><p>提示：</p><p>-231 &lt;= x &lt;= 231 - 1</p><p>进阶：你能不将整数转为字符串来解决这个问题吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 特殊情况：</span></span><br><span class="line">  <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">  <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">  <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">  <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> === <span class="number">0</span> &amp;&amp; x !== <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">      revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">      x = <span class="built_in">Math</span>.floor(x / <span class="number">10</span>);</span><br><span class="line">      <span class="comment">// console.log(x, revertedNumber);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">  <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">  <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">  <span class="keyword">return</span> x === revertedNumber || x === <span class="built_in">Math</span>.floor(revertedNumber / <span class="number">10</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// let res = isPalindrome(12321)</span></span><br><span class="line"><span class="comment">// console.log(res);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-171.Excel 表列序号</title>
    <link href="https://ferrerobomb.github.io/2022/02/03/leetcode-171.Excel%20%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/"/>
    <id>https://ferrerobomb.github.io/2022/02/03/leetcode-171.Excel 表列序号/</id>
    <published>2022-02-03T04:15:49.000Z</published>
    <updated>2022-02-05T13:12:08.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-171-Excel-表列序号"><a href="#leetcode-171-Excel-表列序号" class="headerlink" title="leetcode-171.Excel 表列序号"></a>leetcode-171.Excel 表列序号</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。</p><p>例如：</p><p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>…</p><p>示例 1:</p><p>输入: columnTitle = “A”<br>输出: 1<br>示例 2:</p><p>输入: columnTitle = “AB”<br>输出: 28<br>示例 3:</p><p>输入: columnTitle = “ZY”<br>输出: 701</p><p>提示：</p><p>1 &lt;= columnTitle.length &lt;= 7<br>columnTitle 仅由大写英文组成<br>columnTitle 在范围 [“A”, “FXSHRXW”] 内</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/excel-sheet-column-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/excel-sheet-column-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; columnTitle</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//  26进制</span></span><br><span class="line"><span class="keyword">var</span> titleToNumber = <span class="function"><span class="keyword">function</span>(<span class="params">columnTitle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 序号</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">1</span>; <span class="comment">// 当前位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = columnTitle.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> p = columnTitle[i].charCodeAt() - <span class="string">'A'</span>.charCodeAt() + <span class="number">1</span></span><br><span class="line">        index += p * k <span class="comment">// 由于是26进制，每位都要乘当前的位数</span></span><br><span class="line">        k *= <span class="number">26</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-182.查找重复的电子邮箱</title>
    <link href="https://ferrerobomb.github.io/2022/02/02/leetcode-182.%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/"/>
    <id>https://ferrerobomb.github.io/2022/02/02/leetcode-182.查找重复的电子邮箱/</id>
    <published>2022-02-02T04:04:33.000Z</published>
    <updated>2022-02-05T04:21:04.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-182-查找重复的电子邮箱"><a href="#leetcode-182-查找重复的电子邮箱" class="headerlink" title="leetcode-182.查找重复的电子邮箱"></a>leetcode-182.查找重复的电子邮箱</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>SQL架构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> <span class="keyword">If</span> <span class="keyword">Not</span> <span class="keyword">Exists</span> Person (<span class="keyword">id</span> <span class="built_in">int</span>, email <span class="built_in">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Person</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (<span class="keyword">id</span>, email) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'a@b.com'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (<span class="keyword">id</span>, email) <span class="keyword">values</span> (<span class="string">'2'</span>, <span class="string">'c@d.com'</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (<span class="keyword">id</span>, email) <span class="keyword">values</span> (<span class="string">'3'</span>, <span class="string">'a@b.com'</span>)</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure><p>根据以上输入，你的查询应返回以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>所有电子邮箱都是小写字母。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="comment"># 1.聚合</span></span><br><span class="line"><span class="comment">#  select Email, count(Email) as num</span></span><br><span class="line"><span class="comment">#  from Person</span></span><br><span class="line"><span class="comment">#  group by Email</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查找出现次数大于1的</span></span><br><span class="line"><span class="keyword">select</span> Email <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">select</span> Email, <span class="keyword">count</span>(Email) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line">  <span class="keyword">from</span> Person</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line">) <span class="keyword">as</span> statistic</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">num</span> &gt; <span class="number">1</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用聚合的having</span></span><br><span class="line"><span class="keyword">select</span> Email</span><br><span class="line"><span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(Email) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-88.合并两个有序数组</title>
    <link href="https://ferrerobomb.github.io/2022/02/01/leetcode-88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://ferrerobomb.github.io/2022/02/01/leetcode-88.合并两个有序数组/</id>
    <published>2022-02-01T01:35:07.000Z</published>
    <updated>2022-02-05T04:21:12.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-88-合并两个有序数组"><a href="#leetcode-88-合并两个有序数组" class="headerlink" title="leetcode-88.合并两个有序数组"></a>leetcode-88.合并两个有序数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p>示例 1：</p><p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br>示例 2：</p><p>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br>示例 3：</p><p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p><p>提示：</p><p>nums1.length == m + n<br>nums2.length == n<br>0 &lt;= m, n &lt;= 200<br>1 &lt;= m + n &lt;= 200<br>-109 &lt;= nums1[i], nums2[j] &lt;= 109</p><p>进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; m</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法1 好理解的双指针改变nums1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums1</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; m</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums2</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(arr.length &lt; nums1.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 &gt;= m) &#123;</span><br><span class="line">        arr.push(nums2[p2])</span><br><span class="line">        p2++;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p2 &gt;= n) &#123;</span><br><span class="line">        arr.push(nums1[p1])</span><br><span class="line">        p1++;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums1[p1] &gt;= nums2[p2] ) &#123;</span><br><span class="line">        arr.push(nums2[p2])</span><br><span class="line">        p2++;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(nums1[p1])</span><br><span class="line">        p1++;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">        nums1[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2 直接排序</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    nums1.splice(m, nums1.length - m, ...nums2);</span><br><span class="line">    nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3 双指针改变nums1 【方法1的优化写法】</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> sorted = <span class="keyword">new</span> <span class="built_in">Array</span>(m + n).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> cur;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 === m) &#123;</span><br><span class="line">            cur = nums2[p2++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 === n) &#123;</span><br><span class="line">            cur = nums1[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">            cur = nums1[p1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = nums2[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">        nums1[i] = sorted[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-2154.将找到的值乘以2</title>
    <link href="https://ferrerobomb.github.io/2022/01/31/leetcode-2154.%E5%B0%86%E6%89%BE%E5%88%B0%E7%9A%84%E5%80%BC%E4%B9%98%E4%BB%A52/"/>
    <id>https://ferrerobomb.github.io/2022/01/31/leetcode-2154.将找到的值乘以2/</id>
    <published>2022-01-31T13:38:36.000Z</published>
    <updated>2022-01-31T13:38:54.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-2154-将找到的值乘以2"><a href="#leetcode-2154-将找到的值乘以2" class="headerlink" title="leetcode-2154.将找到的值乘以2"></a>leetcode-2154.将找到的值乘以2</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，另给你一个整数 original ，这是需要在 nums 中搜索的第一个数字。</p><p>接下来，你需要按下述步骤操作：</p><p>如果在 nums 中找到 original ，将 original 乘以 2 ，得到新 original（即，令 original = 2 * original）。<br>否则，停止这一过程。<br>只要能在数组中找到新 original ，就对新 original 继续 重复 这一过程。<br>返回 original 的 最终 值。</p><p>示例 1：</p><p>输入：nums = [5,3,6,1,12], original = 3<br>输出：24<br>解释： </p><ul><li>3 能在 nums 中找到。3 * 2 = 6 。</li><li>6 能在 nums 中找到。6 * 2 = 12 。</li><li>12 能在 nums 中找到。12 * 2 = 24 。</li><li>24 不能在 nums 中找到。因此，返回 24 。<br>示例 2：</li></ul><p>输入：nums = [2,7,9], original = 4<br>输出：4<br>解释：</p><ul><li>4 不能在 nums 中找到。因此，返回 4 。</li></ul><p>提示：</p><p>1 &lt;= nums.length &lt;= 1000<br>1 &lt;= nums[i], original &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/keep-multiplying-found-values-by-two" target="_blank" rel="noopener">https://leetcode-cn.com/problems/keep-multiplying-found-values-by-two</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; original</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findFinalValue = <span class="function"><span class="keyword">function</span>(<span class="params">nums, original</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// console.log(nums[i], original);</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] === original) &#123;</span><br><span class="line">        original *= <span class="number">2</span></span><br><span class="line">        i = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(original);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> original</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-75.颜色分类</title>
    <link href="https://ferrerobomb.github.io/2022/01/30/leetcode-75.%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <id>https://ferrerobomb.github.io/2022/01/30/leetcode-75.颜色分类/</id>
    <published>2022-01-30T05:43:07.000Z</published>
    <updated>2022-01-30T05:43:26.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-75-颜色分类"><a href="#leetcode-75-颜色分类" class="headerlink" title="leetcode-75.颜色分类"></a>leetcode-75.颜色分类</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p>示例 1：</p><p>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]<br>示例 2：</p><p>输入：nums = [2,0,1]<br>输出：[0,1,2]</p><p>提示：</p><p>n == nums.length<br>1 &lt;= n &lt;= 300<br>nums[i] 为 0、1 或 2</p><p>进阶：</p><p>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="number">0</span>; <span class="comment">// 当前指针</span></span><br><span class="line">    <span class="keyword">let</span> p0 = <span class="number">0</span>; <span class="comment">// 0指针</span></span><br><span class="line">    <span class="keyword">let</span> p2 = nums.length<span class="number">-1</span>; <span class="comment">// 2指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 换位函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">i, j</span>)</span>&#123;</span><br><span class="line">        [nums[i],nums[j]] = [nums[j],nums[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cur &lt;= p2)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur &gt;= p0 &amp;&amp; cur &lt;= p2 &amp;&amp; nums[cur] !== <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 遇到0 和p0位置交换</span></span><br><span class="line">            <span class="keyword">if</span>(nums[cur] === <span class="number">0</span>) swap(cur, p0++);</span><br><span class="line">            <span class="comment">// 遇到2 和p2位置交换</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[cur] === <span class="number">2</span>) swap(cur, p2--);</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log([sortColors([2,0,2,1,1,0])]);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://ferrerobomb.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
